(CODE ANSI)

Расширение библиотеки RTC

Если Вы хотите внести в библиотеку свой модуль реального времени RTC, то Вам нужно внести изменения в файле RTC.h:

1.	Откройте файл RTC.h

	в указанном файле объявлены 4 константы:
	#define	RTC_UNDEFINED	0
	#define	RTC_DS3231		1
	#define	RTC_DS1302		2
	#define	RTC_DS1307		3

	в указанном файле объявлены 4 массива настроек модулей:
	RTC_array_BUS  -  указание типа шины и режимов её работы
	RTC_array_STR  -  установка битов регистров модулей при старте
	RTC_array_REG  -  адреса регистров даты и времени
	RTC_ignor_BIT  -  маска для чтения/записи.
	Каждый из этих массив содержит подмассив индекс которого равен константе: RTC_UNDEFINED, RTC_DS3231, RTC_DS1302, RTC_DS1307.
	
2.	Объявите константу с именем Вашего модуля после объявленной константы "#define RTC_DS1307 3" со следующим по порядку индексом
	например: "#define RTC_DS1202 4"
	означает: первый параметр функции инициализации модуля - begin(RTC_DS1202); укажет бибилиотеке на использование 4го элемента массивов настроек.

3.	Добавьте подмассив в конце каждого массива и заполните его:

3.1.	Добавляем подмассив к массиву RTC_array_BUS:
		после последнего элемента данного массива, строка (строка: " /* RTC_DS1307 3 */ {...},")
		добавьте строку с подмассивом каждый из восьми элементов которого является:
		0 элемент: тип шины данных используемый модулем, доступные значения - RTC_I2C или RTC_SI3 или RTC_SPI. (RTC_SI3 - это протокол 3-wire)
		1 элемент: частота шины данных в кГц (от 1 до 255)
		2 элемент: если используется шина I2C, то укажите ID-адрес модуля, иначе укажите активный логический уровень линии выбора модуля (0 или 1) это состояние линии SS или RST при котором модуль принимает и получает данные
		           остальные 5 параметров указываются для шины SPI или SI3, а для шины I2C указываем любое значение в пределах от 0 до 255.
		3 элемент: режим работы при чтении (от 0 до 3) см. описание режимов.
		4 элемент: режим работы при записи (от 0 до 3) см. описание режимов.
		5 элемент: флаг переворачивания данных младшим битом вперед при чтении (0 отправлять старшим битом вперёд, 1 отправлять младшим битом вперед)
		6 элемент: флаг переворачивания данных младшим битом вперед при записи (0 отправлять старшим битом вперёд, 1 отправлять младшим битом вперед)
		7 элемент: слагаемое к адресу регистра для записи (если адреса регистров для чтения даты и времени, отличаются от адресов регистров для записи, то указываем эту разницу, иначе ставим 0)
		например: "/* RTC_DS1202 4 */ {RTC_SI3, 10, 1, 1, 0, 1, 1,-1},"
		означает: шина SI3, 10кГц, активное состояние линии RES = 1, режим чтения = 1, режим записи = 0, переворачивать данные при чтении, переворачивать данные при записи, адреса регистров для записи на 1 меньше чем адреса регистров для чтения

3.2.	Добавляем подмассив к массиву RTC_array_REG:
		после последнего элемента данного массива, строка (строка: " /* RTC_DS1307 3 */ {...},")
		добавьте строку с подмассивом каждый из семи элементов которого является адресом чтения регистра даты и времени
		в следующем порядке: {сек, мин, час, день, месяц, год, день недели}
		например: " /* RTC_DS1202 4 */ {0x81,0x83,0x85,0x87,0x89,0x8D,0x8B},"
		означает: адрес для чтения секунд = 0x81, адрес для чтения минут = 0x83, ... адрес для чтения дня недели = 0x8B,

3.3.	Добавляем подмассив к массиву RTC_ignor_BIT:
		после последнего элемента данного массива, строка (строка: " /* RTC_DS1307 3 */ {...},")
		добавьте строку с подмассивом каждый из семи элементов которого является маской для чтения и записи данных в регистры даты и времени
		в следующем порядке: {сек, мин, час, день, месяц, год, день недели}
		маска нужна для игнорирования битов регистра не несущих информацию путем побитового & со значением этого регистра
		например, если старший бит регистра секунд является флагом CH, а количество секунд = 00, то при установке флага CH в 1, результатом будет 0x80 = 80 секунд, что немного больше необходимого )))
		поэтому установив маску секунд в значение 0x7F, результат будет 0x80 & 0x7F = 0x00 = 00 секунд, вот это уже то, что надо.
		маска действует как при чтении, так и при записи значений в регистры, что предотвращает возможность случайной установки/сброса флагов.
		например: " /* RTC_DS1202 4 */ {0x7F,0x7F,0x3F,0x3F,0x1F,0xFF,0x07},"
		означает: произвести побитовое & значений регистров даты и времени с соответствующими им значениями масок

3.4.	Добавляем подмассив к массиву RTC_array_STR:
		после последнего элемента данного массива, строка (строка: " /* RTC_DS1307 3 */ {...},")
		добавьте строку с подмассивом устанавливающим биты при старте
		у модулей есть биты которые запрещают работу часов полностью или частично, переводят модуль в 12-часовой режим, указывают на вывод меандров и т.д.
		эти флаги нужно установить или сбросить при инициализации модуля, вот для этого и служит данный массив
		0 элемент: количество регистров
		1 элемент: адрес регистра, 2  элемент: биты регистра
		3 элемент: адрес регистра, 4  элемент: биты регистра
		5 элемент: адрес регистра, 6  элемент: биты регистра
		7 элемент: адрес регистра, 8  элемент: биты регистра
		9 элемент: адрес регистра, 10 элемент: биты регистра
		с 0 элементом всё понятно, указываем количество регистров, биты которых требуется проверить, установить, сбросить.
		с элементами 1,3,5,7,9, тоже не должно возникнуть трудностей - это адреса регистров, биты которых требуют проверки, установки, сброса
		а вот значения элементов 2,4,6,8,10, указываются следующим образом:
		каждые 2 бита из значения элемента отвечают за 1 флаг регистра, следующим образом: "0X" - оставить флаг без изменений, "10" - установить флаг в "0", "11" - установить флаг в "1"
		например: " /* RTC_DS1202 4 */ {1,0x81,0b1000000000000011},"
		означает: - количество регистров требующих проверки, установки, сброса флагов = 1
		          - адрес регистра, флаги которого нуждаются в проверке, установке, сбросе = 0x81
				  - в проверке нуждаются 7й и 0й биты регистра 0x81 (7й и 0й флаг)
				  - если 7й бит (флаг) равен 1, то его нужно установить в 0
				  - если 0й бит (флаг) равен 0, то его нужно установить в 1
				  - если 7й бит = 0 и 0й бит = 1, то изменения в регистр записываться не будут
				  - биты (флаги) регистра не нуждающиеся в проверке, установке, сбросе, (6й, 5й, 4й, 3й, 2й, 1й) остаются без изменений.
		предположим, если значение регистра 0x81 = 0xFF, то после вызова функции begin(RTC_DS1202), оно будет равно 0x7F
		предположим, если значение регистра 0x81 = 0x00, то после вызова функции begin(RTC_DS1202), оно будет равно 0x01
		предположим, если значение регистра 0x81 = 0xF0, то после вызова функции begin(RTC_DS1202), оно будет равно 0x71
		предположим, если значение регистра 0x81 = 0x0F, то после вызова функции begin(RTC_DS1202), оно не изменится

На этом расширение библиотеки до Вашего модуля завершено!

Описание режимов:
	В пункте 3.1., элементы подмассива 3 и 4 указывают на режимы работы шины от 0 до 3.
	Режим работы шины - это состояние линии тактирования, при котором читаются биты с линии данных, в протоколах SPI и 3-wire
	- Mode=0:	состояние c линии данных читается по переднему фронту синхроимпульса;
	- Mode=1:	состояние c линии данных читается по заднему   спаду  синхроимпульса;
	- Mode=2:	состояние c линии данных читается по переднему спаду  синхроимпульса;
	- Mode=3:	состояние c линии данных читается по заднему   фронту синхроимпульса;
